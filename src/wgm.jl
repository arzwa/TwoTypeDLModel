# 1. implement  pruning modification 
# 2. implement probability generating functions (condition factor computation)
# 3. implement partial recomputation from a particular node (for MCMC)
"""
    TwoTypeDLWGM
"""
@with_kw struct TwoTypeDLWGM{T,I} <: TwoTypeModel
    λ ::T
    μ₁::T
    ν ::T
    μ₂::T
    q ::Vector{T}
    k ::Vector{Int}
    wgms::Dict{I,Int}
end

Base.NamedTuple(θ::TwoTypeDLWGM) = (λ=θ.λ, μ₁=θ.μ₁, ν=θ.ν, μ₂=θ.μ₂, q=θ.q, k=θ.k, wgms=θ.wgms)
(θ::TwoTypeDLWGM)(; kwargs...) = TwoTypeDLWGM(merge(NamedTuple(θ), (; kwargs...))...)

function wgm!(dag, node, θ)
    @unpack nodes, graph, parts = dag
    idx = θ.wgms[id(node)]
    q = θ.q[idx]
    k = θ.k[idx]
    for n in nodes[id(node)]
        v = outneighbors(graph, n)
        @assert length(v) == 1
        wgmprobs!(parts, n, v[1], q, k)
    end
end

function wgmprobs!(parts, u, v, q, k)
    # u is the WGM node, v is its daughter node
    imax = size(parts, 2) 
    lq = log(q)
    l1mq = log(1.0 - q)
    parts[u, :, :, 1] .= -Inf 
    # for all possible cs and ds
    for c=0:imax-1, d=0:imax-1
        # iterate over admissable as and bs
        apb = k*(c + d)  # a+b = k*(c+d) constraint
        amx = min(imax-1, k*c)        # c ≤ a ≤ k*c constraint
        for a=c:amx
            b = apb - a
            b > imax-1 && continue
            n = (k-1)*c  # additional genes generated by WGM
            # probability of (c,d) [pre WGM] -> (a,b) [post WGM]
            p = log(binomial(n, a-c)) + (a-c)*lq + (amx - a)*l1mq
            p += parts[v, a+1, b+1, 2]
            parts[u, c+1, d+1, 1] = logaddexp(parts[u, c+1, d+1, 1], p)
        end
    end
end

function wgmpgf(θ::TwoTypeDLWGM, n::Node, s1, s2) 
    idx = θ.wgms[id(n)]
    wgmpgf(θ.q[idx], θ.k[idx], s1, s2)
end

function wgmpgf(q, k, s1, s2)
    nmx = k-1
    f10 = 0.0
    for n=0:nmx
        f10 += binomial(nmx, n) * q^n * (1.0-q)^(nmx-n) * s1^(1+n) * s2^(nmx-n)
    end
    f01 = s2^k
    return f10, f01
end

function simwgm(X, p, n)
    idx = p.wgms[n]
    q = p.q[idx]
    k = p.k[idx]
    return _simwgm(X, q, k)
end

function _simwgm(X, q, k)
    n = (k-1)*X[1]
    r = rand(Binomial(n, q)) # retained 
    X′= (X[1] + r, k*X[2] + n - r)
    #@assert k*sum(X) == sum(X′)
    return X′
end
    
